// Service Worker for PWA offline functionality
// This file will be processed by workbox-webpack-plugin during build

// Import workbox modules
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { createHandlerBoundToURL, precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst } from 'workbox-strategies';

/**
 * Returns true if pathname looks like a file path (last segment contains a dot).
 * Uses string operations only to avoid ReDoS from regex backtracking.
 */
function pathnameLooksLikeFile(pathname) {
  const segments = pathname.split('/');
  const lastSegment = segments[segments.length - 1] ?? '';
  return lastSegment.includes('.');
}

const cacheableOk = new CacheableResponsePlugin({ statuses: [0, 200] });

/**
 * Determines if a navigation request should be served with the app shell (index.html).
 * Returns false for non-navigation requests, paths starting with '/_', or file-like paths.
 *
 * @param {Object} params - The route parameters
 * @param {Request} params.request - The request object
 * @param {URL} params.url - The URL object
 * @returns {boolean} True if the request should be served with the app shell
 */
function shouldServeAppShell({ request, url }) {
  if (request.mode !== 'navigate') {
    return false;
  }
  if (url.pathname.startsWith('/_')) {
    return false;
  }
  if (pathnameLooksLikeFile(url.pathname)) {
    return false;
  }
  return true;
}

/**
 * Checks if a request is for a static asset (script, style, or image).
 *
 * @param {Request} request - The request object to check
 * @returns {boolean} True if the request is for a static asset
 */
function isStaticAsset(request) {
  return (
    request.destination === 'script' ||
    request.destination === 'style' ||
    request.destination === 'image'
  );
}

/**
 * Checks if a URL is a same-origin API endpoint.
 *
 * @param {URL} url - The URL object to check
 * @returns {boolean} True if the URL is a same-origin API endpoint
 */
function isSameOriginApi(url) {
  return (
    url.origin === globalThis.location.origin &&
    url.pathname.startsWith('/api/')
  );
}

/**
 * Checks if a request is for a font resource.
 *
 * @param {Request} request - The request object to check
 * @returns {boolean} True if the request is for a font
 */
function isFont(request) {
  return request.destination === 'font';
}

/**
 * Handles the SKIP_WAITING message from the client to immediately activate
 * a waiting service worker without requiring all clients to close.
 *
 * @param {MessageEvent} event - The message event from the client
 */
function handleSkipWaitingMessage(event) {
  if (!event.data || event.data.type !== 'SKIP_WAITING') {
    return;
  }
  globalThis.skipWaiting();
}

// Take control of all clients as soon as the service worker is activated
clientsClaim();

// Precache all of the assets generated by the build process
precacheAndRoute(globalThis.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with the index.html shell.
registerRoute(shouldServeAppShell, createHandlerBoundToURL('/index.html'));

// Cache static assets (JS, CSS, images) with CacheFirst strategy
const staticPlugins = [
  cacheableOk,
  new ExpirationPlugin({
    maxEntries: 60,
    maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
  }),
];
registerRoute(
  isStaticAsset,
  new CacheFirst({
    cacheName: 'static-resources',
    plugins: staticPlugins,
  }),
);

// Cache API responses with NetworkFirst strategy
const apiPlugins = [
  cacheableOk,
  new ExpirationPlugin({
    maxEntries: 50,
    maxAgeSeconds: 5 * 60, // 5 minutes
  }),
];
registerRoute(
  isSameOriginApi,
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: apiPlugins,
  }),
);

// Cache fonts with CacheFirst strategy
const fontPlugins = [
  cacheableOk,
  new ExpirationPlugin({
    maxEntries: 30,
    maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
  }),
];
registerRoute(
  isFont,
  new CacheFirst({
    cacheName: 'fonts',
    plugins: fontPlugins,
  }),
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
globalThis.addEventListener('message', handleSkipWaitingMessage);
