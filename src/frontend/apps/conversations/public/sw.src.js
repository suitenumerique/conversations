// Service Worker for PWA offline functionality
// This file will be processed by workbox-webpack-plugin during build

// Import workbox modules
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { createHandlerBoundToURL, precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, NetworkFirst } from 'workbox-strategies';

/**
 * Returns true if pathname looks like a file path (last segment contains a dot).
 * Uses string operations only to avoid ReDoS from regex backtracking.
 */
function pathnameLooksLikeFile(pathname) {
  const segments = pathname.split('/');
  const lastSegment = segments[segments.length - 1] ?? '';
  return lastSegment.includes('.');
}

const cacheableOk = new CacheableResponsePlugin({ statuses: [0, 200] });

function shouldServeAppShell({ request, url }) {
  if (request.mode !== 'navigate') {
    return false;
  }
  if (url.pathname.startsWith('/_')) {
    return false;
  }
  if (pathnameLooksLikeFile(url.pathname)) {
    return false;
  }
  return true;
}

function isStaticAsset(request) {
  return (
    request.destination === 'script' ||
    request.destination === 'style' ||
    request.destination === 'image'
  );
}

function isSameOriginApi(url) {
  return (
    url.origin === globalThis.location.origin &&
    url.pathname.startsWith('/api/')
  );
}

function isFont(request) {
  return request.destination === 'font';
}

function handleSkipWaitingMessage(event) {
  if (!event.data || event.data.type !== 'SKIP_WAITING') {
    return;
  }
  globalThis.skipWaiting();
}

// Take control of all clients as soon as the service worker is activated
clientsClaim();

// Precache all of the assets generated by the build process
precacheAndRoute(globalThis.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with the index.html shell.
registerRoute(shouldServeAppShell, createHandlerBoundToURL('/index.html'));

// Cache static assets (JS, CSS, images) with CacheFirst strategy
const staticPlugins = [
  cacheableOk,
  new ExpirationPlugin({
    maxEntries: 60,
    maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
  }),
];
registerRoute(
  isStaticAsset,
  new CacheFirst({
    cacheName: 'static-resources',
    plugins: staticPlugins,
  }),
);

// Cache API responses with NetworkFirst strategy
const apiPlugins = [
  cacheableOk,
  new ExpirationPlugin({
    maxEntries: 50,
    maxAgeSeconds: 5 * 60, // 5 minutes
  }),
];
registerRoute(
  isSameOriginApi,
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: apiPlugins,
  }),
);

// Cache fonts with CacheFirst strategy
const fontPlugins = [
  cacheableOk,
  new ExpirationPlugin({
    maxEntries: 30,
    maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
  }),
];
registerRoute(
  isFont,
  new CacheFirst({
    cacheName: 'fonts',
    plugins: fontPlugins,
  }),
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
globalThis.addEventListener('message', handleSkipWaitingMessage);
